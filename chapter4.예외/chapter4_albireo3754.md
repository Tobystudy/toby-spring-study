## 4장
### 4.1 사라진 SQLException
- 기존에 있던 SQLException은 사라지고, jdbcTemplate 기반의 코드에선 SQLException이 보이지 않는다.
- 이 사라진 SQLException을 찾기 이전에 개발자들의 코드에서 발견되는 초난감 예외처리를 알아본다.
	- `try { ... } catch (SQLException e) { System.out.println(e) }`
	- 이렇게 예외가 발생했을때 catch로 잡아낸다고 하더라도, 프로그램 실행중에 비 정상적인 동작을 계속 진행하게 만들기 때문에, 서버의 이상이 있을때 빠르게 찾아내기 힘들다는 문제가 있다.
	- **어떤 경우에도 위와 같은 코드를 만들면 안 된다. 습관이 되면 무서우니 코딩 연습이나 예제를 잠깐 만드는 경우라도 그래선 안된다.**
		- 이 말이 훨씬 인상적이다. 습관이 되면 무서우니 코딩 연습할때도 코드를 너무 막 쓰진 말자.
	- 이렇게 만들바엔 차라리 `catch (SQLException e) { e.printStackTrace(); System.exit(1)`이 훨씬 낫다.
- EJB 시절엔 더 성의없이 throws Exception을 기계적으로 붙여서 예외를 상위로 "던졌다".
	- 이 코드의 문제는 예외가 발생한다는 사실속에 의미 있는 정보가 있는지, 아니면 아무 생각없이 쓴 코드인지 그 문맥을 파악하기 어렵다.
	- 그래서 이 api를 사용하는 클라이언트는 마찬가지로 무의미한 throw를 계속 던지게 만들 가능성이 있다.
- 예외 처리에 대한 베스트 프랙티스: Checked Exception을 남발하지 말자. 무의미한 throw는 코딩을 어렵게한다.
	- Error: JVM에서 일으키는 버그고, 어차피 대응 방법이 없기 때문에 차라리 대응을 하지 않는다.
	- Checked Exception: throw를 쓰던가 catch를 해야한다. 그렇지 않으면 컴파일에러가 발생한다.
	- Unchecked Exception: 주로 NPE와 같은 RuntimeException, throw가 필요 없다.
- 예외처리 방법
	- 예외복구
		- 문제를 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
		- 예시: 연결 불안정시 retry로직
	- 예외처리 회피
		- 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것
		- 예시: throw
	- 예외 전환
		- 예외처리 회피는 책임또한 회피하는데 반해, 적절한 예외로 바꿔서 던져줌으로써 유의미한 의미 부여가 가능하고 디버깅이 쉬워진다.
		- 예시: id중복으로 인한 SQLException시 DuplicationUserIdException과 같은 예외로 바꿔서 던진다.
	- 예외 전환2
		- 예외를 변경해서 던지기 보다 한단계 포장해서 던지는 편이다. 비즈니스 로직으로 볼때 의미가 있거나 복구 가능한 예외가 아니라면 포장해서 던지는편이 낫다.
		- 예시: EJB
- 예외처리 전략
	- 기본전략
		- 엔터프라이즈 서버환경에선 각 사용자의 독립된 요청 중 예외가 발생한 작업만 중단시킨다. 빠르게 작업을 취소하고 서버 관리자나, 개발자에게 통보할 방법을 연구한다.
	- 런타임 체크의 보편화
		- 자바 측에서도 초기 JDK의 API와 달리 최근에 등장하는 표준 스펙은 항상 복구할 수 있는 예외가 아니라면 언체크 예외로 던지고 있다. 
	- 애플리케이션 예외
		- 비즈니스 로직의 예외라고 볼수도 있는 해당 예외는 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 catch 해서 무엇인가 조취를 취하고자 하는 애플리케이션 예외가 있다.
		- 에러가 발생했을 때 과거의(C style) 방식은 -1 ~ 이하의 값을 내려줌으로서 에러를 표현했는데, 표준 상수에 대한 정의도 까다롭고 의사소통 문제 등이 존재한다. 이런 코드를 if문으로 범벅했을 경우엔 코드 파악하기가 매우 어렵다는 문제가 있다.
		- 다른 방법으론 비즈니스 의미를 가진 예외 클래스를 만들어서 던진다. 이 경우 타입체크로 인해서 지저분한 if문이 사라지고 예외 상황에 대응하는 코드를 작성하기가 쉬워진다.
			- 하지만 클래스를 많이 만들고, if문 만큼이나 보기싫은 try catch문이 생긴다는 문제가 있을 것 같다.
- 스프링에서 SQL Exception은 그래서 어떻게됨?
	- 복구할 수 없는 SQLException을 반드시 처리하도록 만들지 않고 DataAccessException 로 래핑해서 던지고 있다. 이것은 unchecked exception이기 때문에 필요한 경우 잡아서 예외처리를 하면 된다.
### 4.2 예외 전환
- SQLException은 애플리케이션 레벨에서 신경 쓰기 어려운 문제들을 담고 있기 때문에 DataAccessException은 그런 상황을 추상화 해준다.
	- JDBC의 한계
		- 비 표준 SQL: 어느정돈 표준화 되어있지만 최적화 등의 문제로 그렇지 않은 경우가 있다.
		- 호환성 없는 SQLException의 DB에러 정보: DB마다 SQL만 다른게 아니라 에러코드와 상태가 모두 다르다.
	- DB에러 코드를 추상화 함으로서 DB 벤더가 바뀌더라도 대응이 가능하도록 한다.
	- 에러를 넘어서 데이터 엑세스 기술에 독립적인 추상화된 예외를 제공한다.
		- ex) 하이버네이트, ibatis, jdbc
	- 하지만 안타깝게도 DataAccessException의 서브클래스들 예를들어 DuplicateKeyException은 아직까지 JDBC를 사용했을 때만 적용된다. 완벽한 추상화는 갈길이 멀다. 그래서 사용할 때도 실제로 사용될 수 있는 코드인지 주의깊은 검토가 필요하다.