## 2. 테스트

스프링이 개발자에게 제공하는 가장 중요한 가치: 객체지향과 테스트
계속해서 변화하는 애플리케이션에 대응하는 첫 번째 전략이 확장과 변화를 고려한 DI/IoC 기술 이고, 만들어진 코드를 확신하고 변화에 대처할 자신감을 주는 테스트가 두 번째 전략이다.

### 2. 1 UserDaoTest 다시 보기
- 만든 코드는 어떤 방법으로든 테스트해야 한다.
- 1장에서는 main() 함수에서 UserDao 오브젝트를 직접 호출하고 화면에 출력해서 테스트를 진행 하였다. 테스트가 있었기 때문에, 설계와 코드를 개선하고도 동작이 같음을 확신할 수 있었다.
- 일반적인 웹을 통한 DAO 테스트 방법의 문제 - DAO를 테스트 하기 위해 화면 부터 서비스 DAO 까지 다만들고 화면에 있는 버튼을 눌러가며 DAO를 테스트 한다.
    - 테스트를 너무 늦게한다.
    - 문제가 발생했을 때 찾아내야 하는 수고가 너무 크다.
- 그래서 필요한 것은 작은 단위의 테스트이다.
    - UserDaoTest를 만들면 웹, 서비스 없이 쉽게 테스트할 수 있다. 심지어 서버에 배포할 필요도 없다.
    - 또한 에러가 났을때 금방 문제를 찾을 수 있다.
    - 이런 작은 단위의 코드 테스트를 **단위 테스트**라 한다.
    - 개발자가 빠르게 스스로 만든 코드에 대한 피드백을 받을 수 있다.
- 하지만 여전히 큰 단위의 통합 테스트도 필요한 경우도 있다.
    - 성공하는 여러 작은 모듈들을 연결 하는것이 큰 단위의 모듈의 성공을 보장하지 않는다.
    - 그럼에도 불구하고 각 단위별로 테스트를 먼저 진행한다면 큰 통합 테스트를 진행할때 발견할만한 작은 이슈들을 빠르게 발견하고 해결할 수 있다.
- 1장의 테스트는 매우 불편하다.
    - 첫번째 커밋으로 돌아가보면, 테스트를 하기 위해서 서버를 껏다 킬때 db를 초기화 시키는 쿼리를 직접 날려야한다. 심지어 방법을 잘 몰라서 쿼리를 두번날려서 테이블을 삭제하고 테이블을 다시 만들고 있다. 매우 하기 싫음.
    - 테스트를 자동으로 수행되도록 구조를 개선하여 "딸깍"만 하면 테스트가 반복해서 실행 & 성공 하도록 만드는 것이 중요하다.
### 2.2 UserDaoTest 개선
- 테스트 검증을 자동화 한다. (커밋 1)
    - 테스트 검증을 자동화 함으로써 출력문을 이해해서 테스트가 성공 했는지 검사하는 것이 아니라 테스트 실패가 나오는지 확인하는 것이다.
    - xUnit 프레임워크를 만든 켄트 벡은 "테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것" 이라고 했다.
- 테스트의 효율적인 수행과 결과를 관리할 수 있도록 한다.
    - main() 에서 해볼만한 테스트의 갯수는 한계가 있다. 그래서 실용적이고 전문적인 자바 테스팅 프레임워크인 JUnit으로 전환한다.
    - 1장에서 프레임워크는 제어의 역전이 기본 원리라고 했는데, 그렇기 때문에 우리는 main도 필요 없고 오브젝트를 만들 필요도 없다.
    - 커밋 2로 이동 경로가 이상하니깐 `@SpringBootTest(classes = [Main::class])` 이걸 붙여주지 않으면 컴파일이 안된다.
        - https://whatasame.tistory.com/2 문제는 아닌듯?
    - 드디어 쿼리를 날리면서 테스트를 하는 과정을 지워본다. (커밋 3)
- get() 예외조건 처리를 좀 더 개선해본다.
    - 예외를 처리하는 방법엔 두가지가 있다. null과 같은 특별한 값을 리턴하는 것 & id에 해당하는 정보를 찾을 수 없다고 예외를 던지는 것이 있다.
    - 저자는 여기서 예외를 던지는 것을 사용하기로 하였다. 정확한 이유는 추론 되지 않지만, 아마 글로벌 익셉션 처리가 단순하기 때문이라는 생각이 든다.
        - https://kt.academy/article/ek-nullable-result
    - junit 5의 테스트는 exception 처리가 람다를 기반으로 변경되었다.(커밋4)
        - https://dkswnkk.tistory.com/441
    - 이런 간단한 쿼리도 테스트 해야하냐고 질문할 수도 있다. 하지만 이런 종류의 테스트가 있다면 나중에 어처구니가 없는 실수로 인한 문제를 방지할 가능성이 생긴다. 그리고 테스트를 만들때는 잘 돌아가는 케이스만 골라서 만드는데, 그러지 말자. 조금 더 나아가면 실패하는 테스트 부터 먼저 만들고 제대로된 테스트를 만드는 TDD 프로세스 까지 나아갈 수 있다.
- 더 개선을 해서 @BeforeEach (책은 옛날 코드 @Before)를 적용해서 UserDao의 초기화를 한방에 진행해보자.
    - 이렇게 함으로써 각 테스트가 서로 영향을 주지않고 독립적으로 동작할 수 있기 때문이다.
    - 테스트를 수행하는 데 필요한 정보나 오브젝트를 **픽스쳐**라고 한다. 일반적으로 픽스쳐는 공통으로 사용되기 때문에 공통으로 묶어서 구현해놓으면 좋다. (커밋 5)
### 2.4 스프링 테스트 적용
- 스프링 테스트 컨텍스트 프레임워크 적용이나... 이미 적용되어 있다. 간단하게 테스트를 통해 같은 ApplicationContext를 공유하는지만 확인해본다. (커밋 6)
- 관심사에 따라서 인터페이스를 DI 해서 테스트 할지, 구체클래스를 DI 해서 테스트를 할지 정하면 된다.
    - 추가질문: 절대 바뀌지 않을 코드인데 인터페이스로 DI를 해야할까?
        - 반론: 절대 바뀔 코드란 없다. 추가로 인터페이스 몇줄을 쓰는 것은 어려운 일이 아니지만 인터페이스를 추가함으로써 그 사이에 서비스 계층을 추가해서 얻는 이득이 매우크다.
        - 개인적으론 인터페이스를 필요할때만 분리하는게 더 좋다는 생각을 하긴하는데, 잘 모르겠다. 그라운드룰로서 적용할때는 인터페이스를 강제하는 것은 의미 있다고 생각하지만 그렇지 않을땐 글쎄...
- 스프링은 비침투적 기술이기 때문에 그 어떤 애플리케이션 로직을 건드리지 않고도 스스로 DI를 해서 ApplicationContext 없이 초 스피드 테스트를 구현할 수 있다. (커밋 7)

너가 야근을 하는 이유는 미리미리 짜야할 테스트를 짜지 않아서 개발 속도를 늦췄기 때문이다. 테스트를 하기 싫은 것은 테스트를 하고싶지 않아서 하고싶지 않은 이유는 테스트가 매우 오래걸리는 작업이기 때문에 테스트가 오래 걸리는 작업인 이유는 테스트짜기 좋은 구조가 아니기 때문이다. 하지만? 스프링은? 아님.
### 2.5 학습 테스트로 배우는 스프링
- 개발자가 자신이 만든 코드가 아닌 다른 사람이 만든 코드와 기능에 대한 테스트를 작성할 필요가 있을까?
    - 있다. 이런 테스트를 학습 테스트라고 하고 다른 사람이 만든 코드에 인풋 아웃풋을 넣고 직접 세운 가정이 맞는지 테스트를 할 수 있다.
    - 이 학습 테스트의 가장 큰 장점은 손쉽게 빠른 피드백을 받아볼 수 있다는 점과 리팩토링 시 도움을 주는 것이다.
    - 또한 테스트 코드, 코드 작성에 대한 훈련과 즐거움까지 챙길 수 있다.
- 학습 테스트 예제를 통해서 ApplicationContext 설정이 잘못되고 있다는 사실을 알았다. (커밋 8)
- 학습 테스트는 같은 기능이지만 다른 방법으로 사용하는 코드를 여러가지로 만들어서 비교해볼 수 있다는 큰 장점이 있다.
