## 7 스프링 핵심 기술의 응용
### 7.1 SQL과 DAO의 분리
- DAO를 잘 분리해서 더 이상 수정할 일이 없다.
	- 그렇지 않다. SQL을 수정할 일이 실제로 가장 빈번하다.
- 그러면 우선 떠올릴 수 있는 솔루션은 무엇일까?
	- SQL을 XML로 뺀다.
	- 하지만 SQL을 DI랑 섞어놓으면 유지보수 관점에서 좋지않다. SQL제공 서비스를 아예 분리해보자.
### 7.2 인터페이스의 분리와 자기참조 빈
- 인터페이스를 설계하고 그 인터페이스의 하나의 구현 클래스만 만들면 된다고 생각하는 것은 오산이다. 인터페이스는 방대한 서브시스템의 관문 역할을 하게 될수도 있다. (파사드 패턴)
	- SQL제공 서비스에 대한 인터페이스를 설계하고 빈 설정정보와는 별개의 XML파일을 읽어오는 서비스를 구현해볼 수 있다.
	- 인터페이스로 내부 구현체들을 분리하게 되면 XMLSQLService를 SQLReader, SQLRegistry, SQLMapFile 총 3개의 인터페이스로 분리하고 하나의 클래스가 3개의 인터페이스를 구현하게 만든뒤, 자기 참조를 하도록 설계를 하게되면 일단 하나의 클래스가 여러 역할을 가지고 있다고 하더라도 손쉽게 확장구조로 변경할 수 있는 가능성이 생긴다.
### 7.3 서비스 추상화 적용
- XML 설정을 가져오는 소스를 인터페이스로 빼면 클래스패스 뿐만 아니라 웹에 있는 URL로도 XML을 가져와서 서비스 추상화가 가능하다.
### 7.4 인터페이스 상속을 통한 안전한 기능확장
- 만약 운영중에 SQL을 긴급하게 변경해야하는 경우가 있다면 어떨까?
	- SQLService는 XML을 메모리에 읽어와서 그대로 사용하기 때문에 운영서버의 XML을 변경하더라도 해당 변경이 반영되지 않는다.
	- 실시간 변경을 반영하려면 인터페이스도 뜯어고쳐야 할 가능성도 있다.
- 하지만 클래스 하나에 모든 서비스의 기능을 때려박지 않았고 차근차근 인터페이스를 분리해서 추상화 한 덕분에 그나마 덜 귀찮은 상황에 놓였다.
	- 확장은 항상 미래에 일어나는 일이라, 지금 당장만 놓고 설계를 하게 된다면 오늘을 위한 설계 밖에 나오지 않는다.
- 확장을 염두해두고 항상 DI가 가능한 구조 특히 두 객체가 인터페이스로 느슨하게 결합된 구조로 구성되는 것이 중요하다.
- 또한 하나의 객체가 충분히 응집도가 높은 작은 단위로 설계됬다고 하더라도, 목적과 관심이 각기 다른 클라이언트가 존재한다면 인터페이스를 통해 더 작게 분리하는 인터페이스 분리 원칙을 고려해야 한다.
### 7.5 DI를 이용해 다양한 구현 방법 적용하기
- SQLRegistry에 동시성 환경을 고려해서 ConcurrentHashMap을 적용한다.
	- DI를 통해 멀티스레딩도 고려할 수 있는 멋있는 구조가 되었음을 강조하고 있다.
- ConcurrentHashMap은 그리 나쁘진 않지만 데이터양이 늘어난다면 부족한 부분이 분명히 존재한다. 아예 EmbededDataBase를 이용해서 개선을 해본다.
### 7.6 스프링 3.1의 DI
- 스프링이 처음 나왔을때와 비교하면 자바는 많이 발전했고 스프링 또한 그 변화에 계속해서 따라가고 있다. 그것이 가능한 이유는 스프링 내부 설계 자체가 스프링의 DI와 객체지향 원칙을 충실히 따랐기 때문이다.
	- 애노테이션
		- 스프링 3.1에 이르러서 애노테이션과 메타데이터를 이용한다면 XML 없이도 자바 어플리케이션을 작성할 수 있게 되었다.
	- 정책과 관례를 이용한 프로그래밍
		- 루비온레일즈의 영향을 받아서 코드를 작성하지 않고도 이미 작성된 기본값과 관례를 이용해서 서비스가 돌아가도록 구성이 다 되어있다.
		- 그래서 이 정책과 관례를 잘못 이해하고 코드를 작성하게 되면 쉽지 않은 상황에 빠질 수 있다.
		- 가능한 명시적으로 작성하면 좋겠다는 생각을 하는 사람도 있고 프레임워크의 간결한 설정을 좋아하는 사람이 있을 수 있다. 스프링에선 두가지 설정이 모두 가능함.
- @Bean, @Component를 설정함으로서 자동 등록을 사용할 수 있다.
	- @Component 자동스켄은 컨테이너가 디폴트로 구현해둔 기능이 아니여서 추가로 등록해주긴 해야한다.
- @Profile과 @ActiveProfiles를 활용하면 같은 Context를 이용하더라도 운영환경과 다른 환경을 분리해서 사용할 수 있다.
	- 한번쯤 활성화된 컴포넌트가 어떤건지 알고싶다면 DefaultListableBeanFactory 의 getBeanDefinitionNames를 출력해보면 된다.
- DB 주소나 계정 정보를 쉽게 넣기 위해선 어떤 방법이 있을까?
	- @PropertySource를 @Configuration에 설정하고 @Environment를 주입해주면 사용할 수 있다.
	- 프로퍼티의 값을 직접 주입받고 싶다면 @Value를 사용하자. 이것을 사용하려면 PropertySourcesPlaceholderConfigurer빈을 스태틱으로 하나 선언해야한다.
- @Import는 모듈화된 빈 설정정보를 가져올때 사용하는 애노테이션인데, 이를 좀 더 의미있는 이름으로 선언하기 위해서 @Enable*\이름으로 설정 후 @Import를 메타 에노테이션으로 추가해보자. (사실상 애노테이션의 typealias 방법이라고 볼 수 있을 듯)


### 추가
- Spring Boot Redis Autoconfiguration
	- https://brunch.co.kr/@anonymdevoo/49
- Spring Boot Autoconfiguration 원리
	- http://dveamer.github.io/backend/SpringBootAutoConfiguration.html
	- https://wildeveloperetrain.tistory.com/292
- @SpringBootApplication는 @EnableAutoConfiguration를 담고있다.
