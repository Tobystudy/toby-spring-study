## 6.  AOP

- AOP는 매우 이해하기 어려운 용어와 개념을 가진 기술이다. 이 기술의 등장배경과 스프링이 그걸 도입한 이유, 그 적용을 통해 얻을 수 있는 장점이 무엇인지에 대한 충분한 이해가 필요하다. 그래야지만 AOP의 가치를 이해하고 효과적으로 사용할 방법을 찾을 수 있다. 또한 까다로운 AOP 학습에 충분한 노력을 투자할 동기도 부여받을 수 있다.
    - 비단 aop 뿐만 아니라 어려운 기술을 공부한다면 항상 why? 를 공부하는게 중요한 이유
### 6.1 트랜잭션 코드의 분리
- 5장에서 코드를 잘 정리했지만, UserService에 Transaction을 위한 코드가 끼어있는 것은 아쉬운 부분이 있다.
- 트랜잭션 적용을 위한 코드를 프록시 패턴으로 리팩토링을 진행하였다.
    - 프록시패턴: https://refactoring.guru/ko/design-patterns/proxy
    - Q?: JDBC Template을 만들땐 같은 문제를 탬플릿/콜백 패턴을 사용하고, Template를 주입받는 방식으로 문제를 풀었는데 두 코드는 어떤 부분이 달라서 다른 패턴을 사용하게 된걸까?
- 트랜잭션 코드 분리의 장점
    - UserServiceImpl은 트랜잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
    - 비즈니스 로직에 대한 테스트를 손쉽게 만들 수 있다.

### 6.2 고립된 단위 테스트
- 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다.
- 복잡한 의존관계를 가진 오브젝트를 테스트 하기 위해선 테스트를 의존 대상으로 부터 분리해서 대상 코드를 고립시킬 필요가 있다.
    - 이를 위해선 Mock 오브젝트를 활용할 수 있는데, 목 오브젝트 작성의 수고가 들지만, 분명히 @RunWith 같은 코드를 제거함으로서 테스트 보상은 기대할 만하다.
- 단위 테스트의 단위 혹은 통합은 정하기 나름인데, 토비의 스프링에서 단위 테스트는 목 오브텍트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 것을 의미한다.
- DAO 같은 경우 여러 개의 단위가 연결되어서 하나의 기능을 수행하기 때문에 단위 테스트를 수행하더라도 여러 개의 단위를 연결해서 테스트하더라도 오류가 발생할 수 있다. 하지만 충분한 단위 테스트를 거친다면 통합 테스트에서 오류가 발생할 확률도 줄어들고 발생하더라도 쉽게 처리할 수 있다.
### 6.3 다이내믹 프록시와 팩토리 빈
- 트랜잭션 코드의 기능만 담은 객체를 분리해서 DI를 하는 방식으로 문제를 해결했지만, 트랜잭션의 구현 내용만 분리 했을 뿐 트랜잭션을 적용했다는 사실은 코드에 남아있다. 클라이언트는 트랜잭션을 이용하면서, 구체적인 비즈니스 로직은 트랜잭션을 적용했다는 사실을 숨기기 위해선 어떻게 해야할까?
    - 이때 사용하는 패턴이 프록시 패턴이고, 자신이 클라이언트가 사용하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 프록시라 부르고 실제 대상은 타겟이라고 부른다.
- 프록시는 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서, 그리고 타깃에 부가적인 기능을 부여하기 위해서이다. 이 두가지 기능은 디자인 패턴에선 다른 패턴으로 분류한다.
    - 데코레이터 패턴
        - 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴이다. 자바의 IO 패키지 InputStream과 OutputStream 구현 클래스는 대표적인 예시이다.
        - 마찬가지로 앞에서 구현한 UserServiceTx또한 비슷한 예시이다.
    - 프록시 패턴
        - 타깃의 추가적인 기능을 부여하진 않고 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우에 사용하는 패턴이다.
        - RMI나, EJB, 각종 리모팅 기술을 이용해 다른 서버에 존재하는 오브젝트를 로컬에 있는 오브젝트 처럼 사용할 때도 마찬가지로 프록시 패턴이 적용되어 있는것으로 볼 수 있다.
- 프록시의 가장 큰 문제는 번거롭다는 점이다. 매번 새로운 클래스를 정의해야하고 일일히 클래스의 모든 메소드 들을 구현해야하기 때문이다.
    - https://jisungbin.medium.com/%EC%BD%94%ED%8B%80%EB%A6%B0-by-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-54aa7252febb (kotlin의 by가 있긴 한데...)
- 이 문제를 해결하기 위해선 자바의 reflection(커밋 22) 과 다이내믹 프록시를 적용해서 문제를 해결할 수 있다.
    - 리플랙션은 클래스 코드를 이용한 메타 정보를 이용한 메타프로그래밍이 가능하다.
    - 다이내믹 프록시는 프록시 팩토리에서 타깃 인터페이스를 제공함으로 만들어지고, InvocationHandler를 구현한 오브젝트의 invoke() 메소드를 호출하도록 해준다. invoke() 메소드를 통해 우리는 인터페이스가 아무리 메소드 많더라도 하나의 메소드로 처리가 가능하도록 만들 수 있다.
        - https://en.wikipedia.org/wiki/Heap_pollution ?
    - kotlin 에서 dynamicProxy를 적용하면서 java의 varargs를 코틀린 코드로 변환하고, 코틀린 코드가 java의 varargs로 컴파일 되는 과정에서 오류가 조금 있어서 수정하였음(커밋 3)
- 이렇게 만들어진 다이내믹 프록시는 DI를 할 방법이 없다.
    - 스프링은 팩토리 빈이라고 하는 스프링을 대신해서 기본 생성자 이외의 오브젝트의 생성로직을 담당하는 특별한 빈을 이용할 수 있다.
- 팩토리 빈과 스프링을 조합함으로써 데코레이터 패턴이 적용된 프록시가 가진 2가지 문제, 대상이 구현하고 있는 인터페이스를 구현해야 하고 여러 메소드에 반복적으로 데코레이팅 코드를 작성해야 한다는 문제점을 해결하였다.
    - 하지만 여러개의 클래스가 같은 부가기능을 사용하고자 한다면? 하나의 타깃에 여러개의 부가기능을 적용하려고 한다면? 코드를 한줄도 쓰지않고 xml 만으로 설정하는 것은 좋았지만, 이 경우엔 xml이 수천줄로 늘어날 수 있다. 이는 사람이 관리할 수 있는 영역을 벗어난다.
    - 또한 TransactionHandler와 같은 부가기능을 적용하기 위한 클래스가 타깃 오브젝트를 바라보고 있기 때문에 같은 오브젝트를 타깃 오브젝트 수 만큼 만들어야 한다. 이것을 해결할 순 없을까? 싱글톤 빈으로 만들어 볼 순 없을까?
### 6.4 스프링의 프록시 팩토리 빈
- 스프링에선 이것을 개선하기 위해서 ProxyFactoryBean을 제공한다.
    - 프록시에서 사용하는 부가기능은 MethodInterceptor를 구현해서 만드는데, InvocationHandler의 경우 타깃 오브젝트에 대한 정보를 알고 있지 않지만 MethodInterceptor는 타깃 오브젝트에 대한 정보를 함께 받아서 타깃 오브젝트와 관계를 끊어서 여러 프록시에서 사용할 수 있고 싱글톤 빈으로 등록이 가능하다.
    - MethodInterceptor의 invoke의 파라미터인 MethodInvocation은 일종의 콜백 오브젝트여서, proceed()를 호출하는 것으로 타깃 오브젝트의 메소드를 내부적으로 실행하는 기능이 있다.
        - MethodInterceptor를 구현한 클래스를 Advice라고 하고 ProxyFactoryBean에 주입해줄때 addAdvice를 이용한다.
        - 이것이 가능한 이유는 ProxyFactoryBean에 있는 인터페이스 자동검출 기능이 타겟 오브젝트가 구현하고 있는 모든 인터페이스를 동일하게 구현하는 프록시를 만들어준다.
            - spring 4.0 버전 미만에는 (책) cglib 을 이용한 프록시에선 생성자 호출 문제가 있다.
            - springboot 2.0부턴 인터페이스를 사용하고 있더라도 기본적으론 cglib을 이용한다. https://yeonyeon.tistory.com/289, https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide
            - kotlin("plugin.jpa") version "1.9.23"를 적용하고 있기 때문에 allOpen이 적용 되었고 allOpen은 public 연산의 경우 aop 적용이 가능하다.
              https://hyeon9mak.github.io/kotlin-jpa-essentials/

- MethodInterceptor는 타깃 정보를 갖고 있지 않는데, 어떻게하면 특정 메소드만 프록시를 적용할 수 있을까?
    - Pointcut이라고 하는 메소드 선정 알고리즘을 프록시에 DI를 해준다.
- 어떤 포인트컷과 어떤 어드바이스가 묶일지는 예상할 수 없기 때문에, 둘을 하나로 묶어서 하나의 어드바이저로 만들어서 proxyPactoryBean에 주입해준다.
### 6.5 스프링 AOP
- 충분히 개선되었지만 여전히 불만이 있다.
    - 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보를 추가해주는 부분이다.
- 지금까지 다뤄왔던 반복적이고 기계적인 코드에 대한 해결책은 2가지가 있다.
    - JDBC API를 사용하는 DAO 코드는 탬플릿과 콜백, 클라이언트로 나누는 방법을 통해 분리를 진행했다.
    - 반복적인 위임 코드가 필요할땐 다이내믹 프록시라는 런타임 코드 자동생성 기법을 이용했다.
- ProxyFactoryBean 설정 문제도 프록시가 자동으로 빈으로 생성되게 할 순 없을까? 일정한 타깃 빈의 목록을 제공하면 자동으로 각 타깃 빈에 대한 프록시를 만들어 내는 방법이 없을까?
    - 스프링은 BeanPostProcessor 인터페이스를 이용해서 만드는 빈 후처리기라는 방법을 제공한다.
    - 빈이 생성될때 마다 스프링은 빈 후처리기에 빈을 보내서 모든 어드바이저의 포인트컷을 이용해 전달받은 빈인지 확인한 후 프록시를 생성 하고 생성된 프록시에 어드바이저를 연결한다.
        - 이것은 Pointcut에 존재하는 getMethodMatcher()가 아니라 getClassFilter()를 이용해서 구현한다.
        - 그래서 클래스 필터에서 필터가 걸리면 아무리 프록시를 적용해도 부가기능은 제공되지 않는 사실을 기억하는 것이 중요하다.
- 이렇게 좋은 기술도 자동으로 무엇을 해준다고 하면 정말 그런지 한 번쯤은 직접 확인해보는 습관을 들이는 편이 좋다. 눈에 보이는 결과도 아니고 확인할 수 있는 코드가 만들어지는 것도 아닌 자동 프록시 생성기 같은건, 잘못 사용하는 바람에 기능이 예상한 대로 동작하지 않아도 예외적인 상황이 발생하기 전에는 쉽게 확인이 안 되는 심각한 문제를 초래할 수도있기때문이다.
    - 아무 빈이나 등록이 되는건 아닌지 확인하는것 또한 중요하다.
- 스프링에선 AspectJ에서 가져온 AspectJ 표현식을 사용하는데, 이것도 꽤나 길어보인다.
- UserService에 트랜잭션을 적용해온 과정을 정리해보자.
    - 트랜잭션 서비스 추상화
    - 프록시와 데코레이터 패턴
    - 다이내믹 프록시와 프록시 팩토리 빈
    - 자동 프록시 생성 방법과 포인트 컷
    - 부가기능의 모듈화
- 이 과정은 전부 어드바이스와 포인트컷을 결합한 어드바이저를 단순하게 만들어서 부가기능을 효과적으로 모듈화 하고 주입하는 방법을 구현한 것이다.
    - 전통적인 객체지향 기술 설계 방법에서 사용되는 object와는 다른 aspect라는 특별한 특징이 있다. 이 aspect는 전통적인 객체지향 설계에서 필요한 부가기능을 제공하기 위한 모듈들이고, 이 설계방법을 AOP라고 부른다.
- 스프링 AOP는 프록시를 이용하고 interface를 이용한 다이내믹 프록시 방법 혹은 바이트코드 조작과 상속을 이용한 cglib을 이용한 런타임 위빙 방식을 사용한다. 하지만 AspectJ는 바이트코드를 컴파일타임에 조작해서 적용하는 방식 또한 가능하다.
### 6.6 트랜잭션 속성
- 트랜잭션 전파는 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식을 말한다.
- 전파(Propagation)
    - required 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 참가한다. (default)
    - supports, mandatory - 이미 시작된 트랜잭션이 있으면 합류하는건 맞지만, 없을땐 전자는 트랜잭션을 진행하지 않고 후자는 Exception
    - NOT_SUPPORTED - 포인트컷을 단순화 하기 위해서 추가된 변수, 클래스 전체에 적용하고 참여하지 않을 함수만 빼버리면 된다.
    - Required_new - 새 트랜잭션을 생성
    - never - 기존 트랜잭션이 있으면 exception
    - nested - 하위 트랜잭션이 부모 트랜잭션에 영향을 주지않는 중첩 트랜잭션을 생성 (반대는 가능)
- 격리(Isolation) https://mangkyu.tistory.com/299
    - SERIALIZABLE
    - REPETABLE READ - InnoDB(MySQL) 에선 이게 기본 https://velog.io/@pppp0722/MySQL-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80Isolation-Level
    - READ COMMITTED
    - READ UNCOMMITTED
- readonly https://hungseong.tistory.com/74
- rollbackOn()
    - 스프링은 기본적으로 복구 불가능한 순수한 예외 이외의 모든 예외는 런타임 예외로 포장해서 전달하고 복구가 가능한 예외는 CheckedException으로 던진다는 가정하에 런타임 예외가 발생하면 트랜잭션 롤백을 진행하는데, 그렇지 않은 경우를 대비해서 만들어진 속성
- 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.
    - https://tecoble.techcourse.co.kr/post/2022-11-07-transaction-aop-fact-and-misconception/
### 6.7 애노테이션 트랜잭션 속성과 포인트컷
- xml을 이용한 방식은 불편하고 어렵다. 이 문제를 해결하기 위해선 스프링 3.0 부터 자바5에 등장한 애노테이션을 많이 사용한다.
- @Transactional은 메소드, 클래스, 인터페이스에 사용하고 이게 적용된 오브젝트는 모두 타깃으로 인식한다. 이때 사용된 포인트컷은 TransactionAttributeSourcePointcut이다.
- 이때 트랜잭션이 부여될 위치는 4곳이 존재하고 옵션의 적용 순서는 메소드 -> 클래스 -> 선언 메소드 -> 선언 타입 의 순서를 따라간다.
### 6.8 트랜잭션 지원 테스트
- AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정할 수 있게 하는 방법을 선언적 트랜잭션이라고 한다. 물론 필요하다면 직접 제어하는 프로그램에 의한 트랜잭션 방식도 함께 사용할 수 있다.
- 트랜잭션 매니저와 트랜잭션 동기화가 있기에 트랜잭션 전파또한 가능하다. 이를 이용해서 테스트를 할때 트랜잭션을 미리 시작한다면 추가적인 메소드를 만들지 않고도 트랜잭션에 모두 참가시키도록 만든 테스트코드의 작성이 가능하다.
    - 동기화를 검증하기 위해선 readOnly로 정의 해보면, 내부 트랜잭션에서 수정을 하고 있기 때문에 Exception이 발생하는 것으로 체크가 된다.
    - 물론 이것 또한 프로그램에 의한 트랜잭션 방식 말고도 테스트 프레임워크에 의해 @Transactional을 적용해서 트랜잭션 매니저를 코드에서 지워버릴 수가 있다. 이땐 항상 롤백을 진행하기 때문에 @Rollback(false)를 이용한다면 트랜잭션을 커밋시키도록 설정할 수 있다. 클래스 전체에 사용하려면 @Transaction(defaultRollback=false)를 이용하면 된다.
- 물론 효과적인 DB테스트를 위해서라면 특정 메소드만 분리하는 방법 보단 테스트 목적에 맞게 @Transactional 속성이 적당히 잘 분배된 테스트클래스를 여러개 만드는게 더 좋을 것이다.

### 6.9 정리
- 트랜잭션 추가자료: https://kghworks.tistory.com/162
