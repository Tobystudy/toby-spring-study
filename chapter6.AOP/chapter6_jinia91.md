# 테스트 / 목 / 설계

## 복잡한 코드, 테스트하기 어려운 코드란?

<img width="739" alt="image" src="https://github.com/Tobystudy/toby-spring-study/assets/85499582/3a86c732-893b-495c-9d37-ff7bc7d215ad">

- 복잡한 코드는 비즈니스 유의성이 높고 의존관계가 많이 엮여 있는 코드다.
- 복잡한 코드는
  - 비즈니스 유의성과 다른 종류의 코드들이 뒤섞여 너무 많은 관심사와 많은 분야를 신경써야 하기 때문에 읽기 어렵다(인지 부하의 문제)
  - 의존성이 얽혀있어서 테스트 스코프를 정의하기도 어렵고 격리가 어렵다

## 토프링의 접근법 - 목사용방식

- 기본적으로 solitary unit test 접근법, 하나의 단위는 클래스 단위이며 다른 의존성을 모두 고립시키는 Mockist 테스트를 단위테스트로 정의
- DDD접근을 하지 않는 웹애플리케이션 코딩방식은 Service 객체가 의존성 제어와 비즈니스 유의성이 강결합되어 테스트 스코프를 줄이기가 쉽지 않음
- 결국 목에 의존하는 방식이 권장됨
- 지나친 목은 리팩토링 의존성을 저하시킨다

## DDD로 설계시
- DDD로 인한 설계의 가장 큰 변화중 하나는 애플리케이션 로직과 비즈니스 로직의 분리
- 도메인 빌딩 블록에 비즈니스 로직을 담고 애플리케이션 레이어에는 이를 제어만 하는 로직만 남김
- 결과적으로 도메인 빌딩 블록은 의존관계가 적고 룰 위주 / 애플리케이션 레이어는 의존관계가 높고 제어 위주 로 분리될 수 있다.

## 단위테스트 vs 통합테스트
- 토비의 스프링은 단위테스트를 solitary , 통합테스트를 social + 외부 의존성 으로 정의했다.
- 로버트 마틴의 정의에 따르면 단위테스트는 solitary + social + 외부 관리 의존성 / 통합테스트를 외부 비관리 의존성 으로 정의

![image](https://github.com/Tobystudy/toby-spring-study/assets/85499582/ce40c926-2302-4fef-9be6-f712171be279)


![image](https://github.com/Tobystudy/toby-spring-study/assets/85499582/eb16a39e-7168-495f-9a6d-f799b4b41322)

![image](https://github.com/Tobystudy/toby-spring-study/assets/85499582/f0af7fd9-a281-4e43-a1c0-f4b5a761a576)


<img width="1241" alt="image" src="https://github.com/Tobystudy/toby-spring-study/assets/85499582/4a380364-ec97-4acb-9fbc-4095d8e0a1bb">

## 그래서 테스트는 어떻게?

- 설계를 통해 비즈니스 룰은 단위테스트, 의존관계 제어는 컴포넌트 테스트로 수행하는것이 더 바람직하다고 생각함


# 데코레이터 패턴, 프록시 패턴
https://github.com/jinia91/DesignPattern/blob/main/doc/Decorator.md
https://github.com/jinia91/DesignPattern/blob/main/doc/Proxy.md
- 구현 방법은 거의 동일하지만 접근 제어 목적이면 프록시, 기능 추가면 데코레이터
- 또한 프록시는 직접 의존하는 방식으로 구현하는편이나 데코레이터패턴은 외부 설정 코드에 의해 조립되는 DI를 선호


# AOP
## JDK 다이내믹 프록시
- jvm 모든 클래스는 그 클래스 자체의 구성정보를 담은 Class 타입의 오브젝트를 하나씩 갖고 있음
- jdk 리플렉션을 이용한 동적 프록시 만들기를 쓰면 손쉽게 프록시 패턴 생성이 가능

      class LoggingDecoratorDynamicProxyTests {
      @Test
      fun `로깅 테스트`() {
          val proxyLoggingHello = Proxy.newProxyInstance(
              Hello::class.java.classLoader,
              arrayOf(Hello::class.java),
              LoggingDecorator(HelloImpl())
          ) as Hello
  
          proxyLoggingHello.hello("jinia91")
      }
      }

- 동적 프록시를 이용해 로깅해주는 프록시 구현 예시
-   
## 스프링 팩토리 빈
- 빈 생성시 특정 방법으로 빈을 생성하게 해주는 인터페이스

> jdk 동적 프록시와 스프링 팩토리 빈을 조합하면 특정 레이어의 공통된 부가기능을 추가해주는 대리객체 생성이 보다 쉬워질 수 있음

## 프록시 팩토리 빈방식의 장점과 한계

### 장점
- 코드의 수정없이 다양한 클래스에 기능 추가가 가능
- 코드의 중복을 줄일 수있음

### 단점
- 설정의 증가. 결국 어떤 객체에 어떤 aop를 적용하겠다는 선언을 해야하므로 설정코드가 증가한다
- 부가기능을 해주는 decorator와 프록시 객체가 프록시할 대상만큼 증가한다. 즉 3배수로 객체수가 증가(타겟, 프록시, 부가기능 제공자)

## 스프링의 프록시 팩토리 빈
- 스프링에서 일관된 방법으로 프록시를 만들수 있게 도와주는 추상 레이어, platformTransactionManager 같은 느낌
- methodInterceptor 인터페이스를 이용해 advisor를 만드므로, 이때 타겟을 생성자로 받지 않아도 되어 싱글턴구현이 가능

### 장점
- advisor를 통해 싱글턴 유지가능
- 여러 advisor를 가질수 있고, 이를 이용해 하나의 대상에 타게팅할 수 있어 팩토리빈 자체도 싱글턴으로 사용 가능해진다. 설정량도 크게 줄어듬

## 타겟을 어떻게 한정할까? 메서드 선정 알고리즘, 포인트 컷

### 포인트컷 표현식
- AspectJ 프레임워크의 표현식을 그대로 사용

### 포인트컷 지시자
포인트컷 표현식은 execution 같은 포인트컷 지시자(PCD : Pointcut Designator)로 시작한다.
 
### 포인트컷 지시자 종류

execution : 메서드 실행 조인 포인트를 매칭 한다. 스프링 AOP에서 가장 많이 사용하며, 기능도 복잡하다.
within : 특정 타입 내의 조인 포인트를 매칭한다.
args : 인자가 주어진 타입의 인스턴스인 조인 포인트
this : 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
target : Target 객체(스프링 AOP 프록시가 가리키는 실제 대상)를 대상으로 하는 조인 포인트
@target : 실행 객체의 클래스에 주어진 타입의 어노테이션이 있는 조인 포인트
@within : 주어진 어노테이션이 있는 타입 내 조인 포인트
@annotation : 메서드가 주어진 어노테이션을 가지고 있는 조인 포인트를 매칭
@args : 전달된 실제 인수의 런타임 타입이 주어진 타입의 어노테이션을 갖는 조인 포인트
bean : 스프링 전용 포인트컷 지시자로 빈의 이름으로 포인트컷을 지정한다.

## 중복문제의 접근방법 : 프레임워크화
- 단순히 코드 중복을 줄이기위해 설계를 변경하고 상속과 디자인 패턴을 사용할 수도 있음
- 또다른 접근법은 중복되는 기계적인 코드와 아닌 정보(메타 정보)를 분리해 메타정보만으로 기계적인 코드들을 생성해내는 프레임워크화

## AOP란?
Aspect Oriented Programming

> 부가 기능 모듈화

- 객체지향을 할때 발생하는 횡단 관심사 문제를 쉽게 해결하기위한 기술
- 사실 하는일 자체는 템플릿 콜백패턴과 큰 차이가 없다.
- 람다가 없던시절이면 모를까, 현대의 jvm 언어는 이를 극복할 람다가 존재한다. 과연 aop를 적극적으로 사용해야할까?

### AOP 적용 기술
#### 동적 프록시 생성
- 프록시를 이용하고 빈 후처리기, 자동 프록시 생성으로 동적으로 생성 및 이용하는 접근법
- 과거에는 jdk Proxy를 사용했으나, 이방법은 인터페이스가 존재해야만 프록시를 만들수 있었다.
- CGLib을 사용하면 인터페이스 없이도 프록시생성이 가능해 현재는 Cglib을 기본 구현기술로 채택하고 있다.
#### 바이트 코드 조작 AOP
- AOP 기술의 원조, AspectJ의 동작
- 바이트 코드를 짜맞추어(위빙) 새로운 바이트코드를 만들어낸다. 일종의 kotlin inline 과 템플릿콜백패턴 조합
- 일반적으로는 동적프록시를 사용하지만 스프링 aop도 설정을 통해 AspectJ를 사용 가능

### 주의사항
- 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할때는 적용되지 않는다.

  
  
