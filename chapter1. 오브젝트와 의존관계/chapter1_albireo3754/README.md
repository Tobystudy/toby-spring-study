# 1. 오브젝트와 의존관계
### 1.1 초난감 DAO
- 스프링은 자바, 특히 객체지향 프로그래밍을 기반으로 하고 있고 먼저 객체지향 프로그래밍 부터 알아본다.
- 사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스가 있다. 코드가 꽤 긴데 이 클래스가 제대로 동작하는지 어떻게 확인할 수 있을까?
    - 단순한 방법은 서버에 배포를 해서 브라우저를 통해 DAO 기능을 사용해 보는 것이다. (End to End 테스트) 하지만 웹브라우저를 통해 DAO 기능을 사용해 보는 것은 너무 부담이 크다.
    - sol1) main()을 이용한 DAO 테스트를 진행한다.
        - 이렇게 테스트를 하면 어떻게 될까? => 개발팀에서 바로 쫓겨난다.
            - WHY? 이것을 개선하는게 스프링을 공부하는것이랑 무슨 상관이 있을까? 바로 스프링을 공부하는 것이 이런 문제 제기와 의문에 대한 답을 찾아나가는 과정이다.
- 1번 커밋 진행
### 1.2 DAO의 분리
- 세상에는 변하는 것과 변하지 않는 것이 있다. 하지만 객체지향의 세계에서는 모든 것이 변한다.
- 그래서 객체를 설계할때 가장 염두에 둬야 할 사항은 미래의 변화에 대비하는 것이다.
- 객체지향 설계와 프로그래밍이 갖는 가장 중요한 장점은 실세계를 모델링 해내는 것을 넘어서, **이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는 데 더 의미가 있다.**
- 미래를 대비하는 데 가장 중요한 과제는 변화에 대비하는 것이다. 동일한 기능 변경을 요청했을때 개발자의 생산성은 기존에 분리와 확장을 고려한 설계가 있었기 때문이다.
- 분리는 변경에 대한 요청을 관심사에 맞게 분리 하는 것이다. 처음에는 모든 것을 한군데 모으는 것이 쉬울진 모르지만 언젠가는 뭉친 관심사를 분리해주는 것이 변경에 대응하기 쉽다.
- 실제로 UserDao 의 관심사를 분리해본다.
    1. DB 커넥션을 가져오는 관심
    2. Statement에 담긴 SQL을 DB를 통해 실행
    3. 리소스 할당 해제
    4. 예외사항에 대한 처리
- 먼저 DB커넥션의 중복 코드를 분리했다.
    - 해당 방식은 객체지향적 방법론을 넘어서 프로그래밍의 기본기이고 메소드 추출 기법이라고 리팩토링에서는 부른다.
    - 변경사항에 대한 검증은 어떻게 진행할까?
        - main()을 반복해서 실행해본다.
    - 네이버와 다음에 각각 다른 종류의 DB를 납품하려면 어떻게 해야할까?
        - 요즘은 상상도 하기 힘든일이라는 생각이 들지만 일단 넘어간다.
        - sol1) 상속을 통해 UserDao를 abstract class로 만들고 커넥션을 가져오는 함수를 가상함수로 만들어서 구체 클래스들이 의존하도록 변경한다.
            - 장점: 상속을 통해서 간단하고 사용도 편리하게 만들었다.
            - 단점: UserDao가 다른 목적을 위해 상속이 이미 되고 있다면, 자바는 다중상속을 허용하지 않기 때문에 다른 목적으로 UserDao에 상속을 적용하기 힘들다.
        - sol2) 화끈하게 클래스를 분리해서 두 코드를 찢어낸다. 하지만 여전히 ConnectionMaker라는 특정 클래스와 그 코드에 종속적이기 때문에 DB커넥션을 자유롭게 가져오도록 확장하기가 힘들다. 커밋2
        - sol3) 인터페이스로 분리하면 userDao는 사용할 클래스가 뭔지 몰라도 된다. 여기 까지만 작업하면 UserDao에서 ConnectionMaker라는 관심을 잘 분리했다. 하지만 여전히 구체 클래스를 알아야할 이유가 남아있다. 그 이유는 클래스의 생성을 UserDao 내부에서 하고 있기 때문이다. 이 관심사를 main() 메소드로 넘기면 더이상 UserDao는 ConnectionMaker를 알지 못하게 된다. 커밋3
- 개방 폐쇄 원칙(OCP)
    - 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀있어야 한다.
    - 높은 응집도와 낮은 결합도를 구현하기 위한 방법이다.
        - 높은 응집도는 하나의 변화에 대해 해당 모듈에서 변하는 부분이 크다는 것을 의미한다. 얘를 들어 ConnectionMaker의 내용을 변경하려고 할때 해당 클래스의 함수만 수정해주면 된다. 다른 곳을 고칠 필요가 없다!
        - 낮은 결합도는 한 모듈의 변경이 다른 모듈에 영향을 주지 않는 느슨하게 연결된 형태이다. 마찬가지로 ConnectionMaker의 예시를 들어보면 sql의 벤더를 바꾸는 것이 UserDao에 영향을 주지 않는다.
- SOLID(객체지향 설계 원칙)
    - SRP, OCP, LSP, ISP, DIP
    - 원칙이라는 건 어떤 상황에서든 100% 지켜져야 하는 절대적인 기준이라기 보다는, 일반적인 상황에 잘 적용 가능한 가이드 라인에 더 가깝다.
- 전략 패턴(Strategy Pattern)
    - 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 분리하고, 필요한 전략에 따라 알고리즘 클래스를 주입해서 사용할 수 있는 패턴이다.
### 1.4 IoC
- UserDaoTest는 테스트라는 관점에선 훌륭한 코드이지만 관심사의 분리가 덜 되었다. 바로 구현 클래스를 어떤 것을 사용할지이다.
- 해당 분리를 담당할 클래스를 일반적으로 팩토리라고 부른다. DaoFactory 클래스를 생성하고 커밋4 진행하였다.
- 이 팩토리를 이용해 설계도를 코드에서 분리해냈다.
- 제어의 역전이라는 개념이 있다. 일반적인 프로그램은 프로그램이 시작되는 시점에 사용할 오브젝트를 생성하고, 메소드를 호출 or 오브젝트를 생성을 반복해서 일련의 순차적인 형태로 진행된다. 제어의 역전은 이런 흐름을 거꾸로 뒤집어서, 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않고 제어 권한도 위임한다.
    - 이런 기술이 적용된 대표적인 예시는 프레임워크다. 단순히 거대한 라이브러리를 프레임워크라고 우리는 부르지 않는 이유이다.
- 지금까지 작업한 내용은 자연스럽게 관심사를 분리하고 책임을 나누는 과정이 였는데, 이 코드가 IoC가 적용된 코드가 된다.
### 1.5 스프링의 IoC
- 스프링이 제어권을 관리하고 관계를 맺는 오브젝트를 Bean이라고 부른다.
- IoC 오브젝트를 빈 팩토리라고 부르고, 이 기능을 확장한 애플리케이션 컨텍스트를 일반적으로 사용한다.
- @Configuration은 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 하는 어노테이션 이고, @Bean이라는 어노테이션을 통해 빈을 반환할 수 있도록 구현한다. 이를 커밋 5번에 진행한다.
### 1.6. 싱글톤 레지스트리와 오브젝트 스코프
- DaoFactory를 직접 사용하는 것과 스프링의 애플리케이션 컨텍스트를 사용하는 것의 차이는 실제로 테스트를 진행해보면 알 수 있다. (커밋 6)
- 애플리케이션 컨텍스트는 IoC 컨테이너의 역할도 하지만, 싱글톤을 저장하고 관리하는 싱글톤 레지스트리 이기도 하다. 그래서 스프링은 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.
- 기본적으로 싱글톤 빈을 만드는 이유는 스프링이 엔터프라이즈 시스템 특히 서버 개발을 위해서 만들어졌는데, 대규모 트래픽 환경에서 각 로직을 담당하는 오브젝트를 새로 만들어서 사용하면 GC와 오브젝트 생성 비용으로 인해 서버가 감당하기 힘들었기 때문이다.
- 싱글톤 패턴
    - 싱글톤 패턴은 조심스럽게 써야한다.
        - private 생성자를 갖고 있어서 상속할 수 없다.
        - 테스트하기 어렵다.
        - 특히 서버환경에서는 싱글톤이 하나만 만들어 지는것을 보장하지 못하기 때문이다.
            - 특히 자바 환경에서 클래스 로더를 어떻게 구성하느냐에 따라서 여러 오브젝트가 만들어질 수도 잇고, 여러 개의 JVM에 분산되서 설치되는 경우엔 각각 독립적으로 오브젝트가 생길 수 있다.
        - 전역 상태를 만들 수 있다.
- 싱글톤 레지스트리
    - 스프링은 자바의 싱글톤 패턴의 구현 방식을 이용하지는 않고 스프링이 관리하는 기능을 제공한다.
    - 하지만 여전히 전역 상태의 문제를 해결하지는 못하기 때문에 주의해서 사용하는 방법 뿐이다.
### 1.7 DI
- IoC는 너무 제너럴한 용어라서 의존성 주입이라는 DI 컨테이너로 부르는 경우도 많다.
- 의존성 주입은 클래스가 런타임시 의존관계가 드러나지 않고 인터페이스에만 의존해서 다이나믹하게 주입받게 한다.
- IoC에는 의존 관계 주입 말고도 스스로 의존성을 검색하는 dependency lookup이라는 방법도 있다. 대부분의 경우 의존성 주입이 깔끔하지만 의존관계 검색 방법을 사용해야할 때도 있다. 예를 들어 main() 함수에서 의존관계 검색을 통해 getBean()을 최초 1회 호출해야 한다.

### 1.8 XML을 이용한 설정
- 과거에는 자바 코드를 수정하고 클래스를 다시 컴파일하지 않고 XML을 통해 설정정보를 쉽게 주입할 수 있도록 하곤 했다. 스프링부트를 이용하는 최근의 트렌드는 아닌듯하다.