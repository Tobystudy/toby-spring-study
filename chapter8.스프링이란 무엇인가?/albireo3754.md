## 8장 스프링이란 무엇인가?
### 8.1 스프링의 정의
- 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크
	- 애플리케이션 프레임워크
		- 특정 기능을 위한 프레임워크를 넘어 애플리케이션 내에 전방위적으로 개발을 하기위한 도움을 주는 프레임워크
	- 경량급
		- EJB와 같은 과도한 엔지니어링이 적용된 기술과 대비된 톰캣이나 제티같은 기본적인 서버환경에서도 잘 동작하도록 설계된 프레임워크
		- 또한 프레임워크와 서버환경에 의존적인 부분을 제거하여 코드에 불필요한 부분을 제거 하였다.
	- 엔터프라이즈 개발을 편하게
		- 엔터프라이즈 개발을 편하게 하려다가 오히려 더 복잡해진 EJB와 다르게 초기 설정만 되면 더이상 신경쓰지 않아도 되는 프레임워크
	- 오픈소스
		- 오픈소스의 장점인 투명함과 VMWare가 관리해주는 안정성까지 두루두루 갖추고 있다.
### 8.2 스프링의 목적
- 스프링의 기능과 API를 단순히 외운다고 개발을 잘 할 수 있는 것이 아니다.
- 스프링의 목적을 이해하고 궁극적으로 이루려고 하는 것을 정확하게 파악하여야 한다.
- 엔터프라이즈 개발이 복잡하기 때문에 그 복잡도를 낮추기 위해서 스프링을 사용한다.
	- 기술적인 제약조건과 요구사항이 늘어난다.
	- 핵심기능에 해당하는 비즈니스 로직의 복잡함이 증가하기 때문이다.
	- 비즈니스 로직과 기술적인 복잡함이 한데 얽혀 있으면 복잡함이 몇 배로 가중된다.
	- 각각의 복잡함의 원인은 제거할 수 없는 대상이다. 우리가 해야할 것은 두 가지 복잡함이 한데 어우러지는 것을 막는 것이다.
- EJB 또한 그 문제를 해결하기 위해서 등장한 프레임워크 이지만 EJB 환경에서 동작하기 위해 특정 클래스를 상속하고, 특정 인터페이스를 구현하고, 서버에 종속적인 서비스를 통해서만 사용하게 했던 것이 패착이였다.
	- 스프링은 EJB의 실패를 교훈으로 삼아서 비침투적인 전략을 택했다.
- 스프링의 기술적 복잡함을 상대하는 전략
	- 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적인 JavaEE개발 환경에 대한 스프링의 공략 방법은 서비스 추상화이다.
	- 기술적인 처리기능을 담당하는 코드가 성격이 다른 코드에 섞여서 등장하는 경우엔 AOP를 이용해 기술과 비즈니스 로직의 혼재로 발생하는 복잡함을 해결하였다.
- 비즈니스 로직의 복잡함을 상대하는 전략
	- DB에 비즈니스 로직을 두는 방식을 애플리케이션 안으로 옮겨와 객체지향 언어의 장점을 살리고 비침투적인 스프링의 특성을 이용해서 해결하였다.
- 두가지 모두에 사용된 핵심 도구는 객체지향과 DI이다.
	- DI는 좋은 오브젝트 설계의 결과물이면서 동시에 DI를 열심히 적용하다 보면 객체지향 설계의 원칙을 잘 따른 장점을 살린 설계가 나올 수도 있다.
	- 스프링이 서비스 추상화를 이용해 기술적인 코드를 도메인에서 분리해냄으로써 복잡한 순수한 비즈니스 로직만을 담은 코드가 쉽게 객체지향 설계를 통해서 복잡성을 해결할 수 있게 만들었다.
### 8.3 POJO 프로그래밍
- EJB와 대조적으로 기술적, 외부 환경의 요인을 하나도 받지 않는 순수한 자바 오브젝트
- 특정 기술과 환경에 종속되지 않기 때문에 테스트와 디버깅, 개발이 쉽다.
- 또한 특정 규약이 필요하지 않아 객체지향 설계를 자유롭게 할 수 있다.
- 스프링을 이용하면 POJO 프로그래밍이 가능하고 엔터프라이즈 기술의 복잡함은 스프링을 통해서 분리하고 비즈니스 로직의 복잡함은 POJO의 특성을 살려서 해결한다.
### 8.4 스프링의 기술
- POJO 개발을 손쉽게 할 수 있는 세 가지 가능 기술은 IoC/DI, AOP, PSA이다. 각 기술을 통해 객체지향의 원리를 적용해서 좋은 애플리케이션을 만들 수 있을 뿐만 아니라, 스프링이 중요한 가치를 두는 객체지향의 원리를 충실히 적용해서 나온 결과이기도 하다.
- IoC/DI
	- 스프링의 가장 기본이 되는 기술이자 스프링의 핵심 개발 원칙이다. 두 개의 오브젝트를 분리하는 이유는 무엇일까? 바로 유연한 확장이 가능하게 하기 위해서이다.
	- 핵심기능의 변경, 핵심기능의 동적인 변경(프록시 패턴), 부가기능 추가(데코레이터 패턴), 인터페이스의 변경(어댑터 패턴), 프록시, 탬플릿과 콜백, 싱글톤과 오브젝트 스코프, 테스트는 IoC/DI와 객체지향을 잘 사용했을때 나오는 강점이다.
- AOP
	- 위의 수많은 강점을 가진 OOP 또한 점점 복잡해져 가는 애플리케이션의 요구조건과 기술적인 난해함을 모두 해결하는데 한계가 있다.
	- AOP를 적용하기 위해선 자바 언어의 특성을 이용한 다이내믹 프록시 기법이나 그것을 뛰어넘는 AspectJ같은 것을 적용하면 된다.
		- @Configurable - https://dhsim86.github.io/web/2019/05/21/spring_@configurable-post.html
		- 이렇게 쓸거면 그냥 @Component를 쓰고 프로토타입 스코프로 만들면 안되나?
- PSA(Portable Service Abstraction)
	- 환경과 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 해주는 PSA가 필요하다. POJO로 개발된 코드는 특정 환경이나 구현 방식에 종속적이지 않아야 하기 때문에 필요함.
	- 트랜잭션 서비스 추상화 코드는 PlatformTransactionManager 인터페이스를 구현한 빈을 등록해주면 되는데 바로 그것이 예시다.