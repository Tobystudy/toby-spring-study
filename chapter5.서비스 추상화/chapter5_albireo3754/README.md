## 5. 서비스 추상화
- 기존 코드를 싹 날리고 필요한 코드만 남겨서 리부트를 시작했고, UserDaoTest가 제대로 통과하는 것을 확인하였다.
###  5.1 사용자 레벨관리기능 추가
- 먼저 User에 Level, Login, Recommend를 추가하고 기존 코드에 새로운 기능을 추가하기 전 테스트를 먼저 만들었다. (TDD)
- UserDao를 수정하면서 Kotlin Enum에 적합하게 매핑하기 위한 코드를 추가하였고, 테스트를 통과시켜서 아주 빠르게 테스트를 잡아내었다. (커밋 1)
- 빠르게 update 테스트 함수와 User에 update 함수를 추가하였다. 하지만 꼼꼼한 개발자라면 이 테스트에 불만을 가진다.
    - update에 WHERE절을 빼먹는다고 하더라도 현재 만들어진 테스트를 통과하기 때문이다. (커밋 2)
    - 이렇게 잘못된 테스트는 충분히 문제를 야기할 수 있는 코드가 만들어질 수 있다.
    - 이 테스트를 커버하기 위해선 영향을 받는 로우의 수를 측정하거나, 다른 임의의 로우에 영향이 가는지 확인하면 된다.
    - where절을 추가해야만 통과하는 테스트를 만들었고 update를 수정하였다. (커밋 3)
- 레벨 관리 기능을 어디 구현할까? UserDaoJdbc는 적당하지 않다. 비즈니스 로직 서비스를 제공한다는 의미에서 클래스 이름은 UserService가 적당하다.
    - 테스트 - 구현 방법으로 upgradeLevel()을 구현했고, 빠져있던 getAll도 구현했다. (커밋4)
- 사용자에 관한 비즈니스 로직은 이 정도면 충분해 보이지만 처음 가입하는 사용자는 기본적으로 BASIC이어야 한다는 비즈니스 로직이 있다. 이 로직은 어디에 있어야 할까?
    - UserDaoJdbc, User 등의 후보지가 있지만 부적합하다. 비즈니스 로직에 의한 초기화이기 때문에 Service가 적절해 보인다 라고 한다. 하지만 나는 이걸 굳이 널러블 하게 구현하고 싶지 않아서 User 생성시 초기화 시켜주도록 구현하는 방법을 선택한다.
- 비즈니스 로직을 작성 했으니 이번엔 리팩토링을 진행해본다. (커밋 5)
    - 객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 오브젝트에게 작업을 해달라고 요청한다.
    - UserService가 레벨을 가져와서 다음 레벨로 레벨업 시키는 것이 아니라 User에게 레벨업하라고 요청하고 db에 저장하는 비즈니스 로직만 진행하는 것이다.
    - 이러한 리팩토링도 테스트를 통해서 계속해서 검증이 가능하다.
    - User측에 로직이 들어갔기 때문에 테스트를 추가하면 되는데, 이 테스트는 스프링 빈이 아니여서 금방 만들고 검증해볼 수 있다.
- 사용자 업그레이드 정책을 UserService에서 분리하는 방법을 고려할 수 있는데, 그래야지 연말 이벤트나 새로운 서비스 홍보기간 중에 다른 레벨 업그레이드 정책을 사용할 수 있을 것이다.
    - 특정 기간동안 사용할 코드를 위해 특정 정책으로 분리하면, 이벤트전에 미리 서버를 기동 시켜놓나? 어차피 빈주입은 서버가 뜰때 된다고 생각하면 별로 우아한 방법으로 처리할 수 있진 않을것 같은데?
### 5.2 트랜잭션 서비스 추상화
- 만약에 유저 업그레이드 중 서버 장애가 난다면?
    - 일부 유저만 업그레이드 시키는 것이 아니라 모든 유저를 다시 롤백시키는게 낫다.
- 이걸 테스트하려면 어떻게 할까?
    - 테스트를 위해서 기존 서비스를 고치진 말고 테스트의 목적에 맞는 테스트 더블을 만드는게 맞다.
- 내부클래스 이기 때문에 static으로 선언한다.
    - https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9E%90%EB%B0%94%EC%9D%98-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-static-%EC%9C%BC%EB%A1%9C-%EC%84%A0%EC%96%B8%ED%95%98%EC%9E%90
    - 코틀린에선 companion object가 상속이 되지않는듯 하다.
    - 어쨌든 테스트를 돌려보면 결과는 원하는대로 나오지 않는다.
- 왜? DB는 하나의 SQL 명령엔 트랜잭션을 보장 해주지만, 여러개의 쿼리는 그렇지 않는다. 그래서 트랜잭션 범위를 지정해야 하는데, jdbc는 autoCommit 옵션으로 인해서 하나의 쿼리를 실행할때마다 자동으로 커밋을 날려서 트랜잭션을 진행한다. 이렇게 범위를 설정해주는 것을 트랜잭션의 경계설정이라 한다.
- 비즈니스 로직의 트랜잭션, 즉 여러개의 sql이 필요할 때 트랜잭션을 보장하기 위해서는 DB Connection을 시작하고, 트랜잭션을 시작 후 커밋 or 롤백, db connection을 닫아주는 작업까지 완료해야 하는데 이러면 한심한 UserService가 또 만들어지는 결과가 나타난다.
    - try/catch/finally 블록이 다시 코드에 등장한다.
    - 비즈니스 로직을 담당하는 UserService는 connection을 알게 된다.
    - 더이상 UserDao는 데이터 엑세스 기술에 독립적일 수 없다.
- 스프링은 이 딜레마를 제거할 우아한 방법을 제공한다.
    - 트랜잭션 동기화(TransactionSynchronizations) 방식인데, 해당 방식은 작업 스레드마다 독립적인 Connection풀을 만들어서 JdbcTemplate과 연결되어서 멀티스레드 환경에서 충돌을 걱정할 필요 없고 UserDao가 Connection을 사용한다고 노출할 필요가 없다.
    - 스프링이 처리해주는 방식 덕분에 비즈니스 로직 레벨의 트랜잭션을 적용했지만, JdbcTemplate나 Connection파라미터를 계속 물고 다니지 않아도 된다.
- 이 방식은 로컬 트랜잭션 방법인데, 하나의 DB Connection에 종속되기 때문에 여러 DB를 하나의 트랜잭션을 만들 수 없다. 자바는 JDBC이외의 글로벌 트랜잭션을 지원하기 위해 트랜잭션 매니저를 지원하기 위한 API인 JTA를 제공하고 있다.
    - 이 트랜잭션이 정확하게 어떤지는 둘째고, 로컬 트랜잭션이나 글로벌 트랜잭션을 제공하기 위해서 어떻게 추상화를 해야할까?
    - 스프링은 이걸 해결하기 위해서 PlatformTransactionManager를 제공하고 있다.
        - 그래서 DB Connection 방법에 따라서 트랜잭션 매니저를 바꿔끼우면 되지만 UserService가 트랜잭션 매니저 구현 클래스가 무엇인지 알게 된다.
        - 당연히 DI로 해당 문제를 수정하면 된다. (커밋 5)
### 5.3 서비스 추상화와 단일 책임 원칙
- UserDao와 UserService는 애플리케이션 로직을 담은 코드의 추상화를 진행 했지만, 트랜잭션의 추상화는 로우레벨의 트랜잭션 기술이라는 다른 계층의 특성을 갖는 코드를 분리한 것이다.
- 애플리케이션의 로직에 따른 수평적인 구분이든, 기술이라는 수직적인 구분이든 서로 영향을 주지 않으면서 확장할 수 있는 구조는 스프링의 DI 기술 덕분 이다.
- 이러한 적절한 분리는 단일 책임 원칙(SRP)을 만족한다. UserService 함수를 실행하면 많은 동작이 진행되지만 UserService가 변경될 이유는 단 한가지 서비스 로직이 변경되었을 때 뿐이다.
- 만약 단일 책임 원칙을 만족하지 않는다면 한가지 이유로 변경을 하더라도 수많은 코드를 수정해야만 한다. 이는 실수가 일어날 확률을 올리고 치명적인 버그를 야기한다.
- 단일 책임 원칙은 결국 좋은 프로그래밍 원칙과 서로 관련이 있다. 하나를 챙기려 하면 자연스럽게 하나가 챙겨진다. 일일이 설계 원칙이니 디자인 패턴이니 따라가긴 힘들지만 기능이 동작한다고 해서 코드에 쉽게 만족하지 않고 계속 다듬고 개선하려는 자세가 필요하다.
- 그 과정에서 스프링의 DI는 핵심적인 역할을 했고, 좋은 설계와 코드를 만드는 과정에서 사용되는 가장 중요한 도구이다.
### 5.4 메일 서비스 추상화
- 유저 업그레이드 후 메일 발송 서비스를 구현하였다. (커밋 6)
- 당연히 메일 서비스 서버가 없으면 메일 발송이 불가능하다.
    - 나는 Java api로 제공해주길래 메일 발송서버가 필요 없는줄 알았다.
    - 그러면 테스트코드는 돌리지 않을 것인가?
    - 테스트용 메일 서버를 구축하면 유저한테 영향을 주지 않고도 충분한 테스트를 할 수 있다.
    - 하지만 이 테스트 서버조차 구축하는건 품이 많이 들고 유지하는 비용도 생각해야한다.
- 테스트를 위한 서비스 추상화를 통해서 이 문제를 해결해본다. (커밋 7)
- 저번 장에서 트랜잭션이라는 로우레벨 기술을 추상화 했다면, 이번엔 메일 발송 서비스라는 테스트하기 까다로운 로직을 분리해서 서비스코드에 DIP를 적용해서 로우레벨 기술에 대한 의존성을 사용자 관리 서비스에서 드러낼 수 있다.
- 이렇게 분리한 테스트 서비스는 쉽게 DummySender를 구현하는데 활용될 수 있다.
    - 먼저 테스트를 할 수 있는 환경부터 작성해주었다.(커밋 8)
    - 책에선 setter주입 방식으로 아주 손쉽게 테스트를 작성해주었지만, 현재 시점(240415)에 많이 사용되는 생성자 & 스프링 부트 환경에 적합한 방법을 찾아야한다.
        - https://www.springboot.kr/posts/spring/required-a-single-bean-but-3-were-found/
        - https://goddaehee.tistory.com/211
        - 생성자는 직접 호출하는 상황 (커밋 9) vs MockBean을 활용 하기 (커밋 10)
### Mysql 트랜잭션
- https://mangkyu.tistory.com/299 - mysql 트랜잭션 고립
- https://kghworks.tistory.com/84 - rdbms 트랜잭션 고립